# 数据安全保障
数据安全是最为重要的点，如果无法保障数据的安全，那么后续的其他功能就失去了意义。  
首先数据复制的流程可以分为两种场景：
1. 两个 zone 之间正常复制。
2. 切换 zone 的时候数据复制。
3. 数据从零开始全量复制。

而这两种场景优惠面对三种 case：
1. 新增数据的时候。
2. 删除数据的时候。
3. 更新数据的时候。

三种场景加上三种 case 在加上各种一场情况下如何处理。

## 保证任何时候一份数据只会被一个 Zone 写入
如果数据可以同时被两个 Zone 写入，那么面对数据冲突就无法处理，算法甚至人工都不一定能判断出来那条才是正确的。而且在任意一个时间点只允许被一个 Zone 写入并不会引起业务的问题。也能满足场景需要，因为在网关层会反向代理到正确的 Zone。所以设计了一系列策略来保障任何一个时间只会被允许一个 Zone 写入。
### 规则检查
在配置被提交之前就会对配置的规则进行检查，确保配置的每一个 ZSID 不会被一个以上的 Zone 判断为正确。验证方法为，每个 ZSID 尝试在每个 Zone 的进行检查，如果有一个以上的为通过，则配置检查失败。不允许提交。

### 第一次上线
第一次上线的时候，不管是一个 Zone 还是多个 Zone ，因为有规则检查，被允许提交的配置可以保障不会有一个以上的 Zone 允许写入。也没有切换等中间态，可以保障 Zone Sharding 的安全。

### Zone 切换
最有可能出现多个 Zone 写入的场景是 Zone 切换的时候，比如把 A 地区的用户从 Zone A 切换到 Zone B。这个过程需要保障新老两份规则不能同时生效，否则两个规则冲突，就会出现一个 ZSID 可以同时被两个 Zone 处理的场景。我们以 PiDAL 为例子，在切换 Zone Sharding 规则的时候是如何处理的，网关层等其他地方时实现的思路是一致的。假设场景为要把 ZSID 为 1 的请求从 Zone A 切换到 Zone B。  

#### 1. PiDAL 实例 Keepalive  
定时比如每 5 秒，就向 PiMMS 同步状态和对比自己的配置和 PiMMS 的是否一致，如不一样就切换为 PiMMS 的配置。在日常的状态下 Keepalive 机制也能尽早的发现 PiDAL 实例的问题并告警，比如连续 4 个周期没有收到 PiDAL 的请求，就认定 PiDAL 实例异常告警处理。如果 PiMMS 发现实例有问题，需要先处理掉问题之后才允许做变更操作。Keeplive 的检查周期和报警周期影响到服务不可用的最长时间，比如每 5 秒检查一次，4 个周期异常开始报警，就意味着最长 20 秒会才会发现问题。这个可以根据业务情况和 SLA 要求进行配置。

#### 2. 记录当前状态便于操作回滚  
在执行变更之前，记录下当前的状态，在遇到异常情况的时候可以及时回滚，保障数据安全和业务可用性。

#### 3. 推送变更记录 1: 把 Zone A 和 Zone B 里的 ZSID = 1 的分发状态置为 BLOCK。  
这条变更记录被应用之后效果为：禁止所有写操作，对所有写操作返回错误：Zone resharding block error。   
如果在指定时间内 PiDAL 实例都接收到请求并正确返回。就意味着所有实例已经接收到来变更，就可以继续下一步操作。但是这一步也可能出现意外，操作回滚。回滚时候是能保证数据安全的，针对每种异常情况的论证：

1. 变更记录没能到达某个实例、没能接收到这条变更  
这种情况下，执行回滚，把 ZSID = 1 的规则状态回滚为为 ACTIVE， PiMMS 会向所有的实例推送这个变更。如果这个实例能收到这个变更，数据和现在的状态一致，所以状态是正确的。如果在回滚的时候某个已经应用变更记录 1 的实例没能收到回滚请求的时候，这种情况下这个实例的状态为 BLOCK，是不会产生写请求的，所有数据是安全的，因为 PiDAL 的 Keepalive 机制，这个实例的状态也会最终保持和 PiMMS 一致。

2. 实例已经挂掉  
执行回滚和 3.1 的场景一样，当这个挂掉的实例在恢复的时候会从 PiMMS 从新拉取一份元数据，这就会保持数据一致了。

3. 实例接收到变更记录但是 PiMMS 没能正常收到响应。  
执行回滚，和 3.1 的异常处理一样，就算在回滚的时候，有个别实例没能正常接收到请求，Keepalive 机制也会保障最终状态一致。

4. 实例正常处理了变更记录 1 ，而且 PiMMS 也正常接收到了变更结果，但是之后实例挂了  
这种情况在第一步是无法发现的，因为第一步已经结束了。但是这种 case 会在 第二步被发现并被处理。

#### 4. 推送变更记录 2: 把 Zone A 和 Zone B 里的 ZSID = 1 规则置为由 Zone B 处理。并将状态置为 RESHARDING。  
这一步开始切换配置，这条变更被应用后，所有实例规则变更，而且依然禁止写操作。对写操作返回错误：Zone resharding block error。如果所有实例正确影响配置后，可以继续执行下一步，如果有异常情况，执行回滚。这个时候能保证数据是安全的。

> 这一步执行完成后记录下切换的时间，后续逻辑机制会用到。如果对本地时间漂移问题很敏感可以使用 [PiLCS](/pilcs/introduction) 解决此类问题。

1. 变更记录没能到达某个实例或者实例挂掉  
网络丢包或者正常处理完第一步的时候实例挂掉了，到这一步的时候就会被发现，这个时候执行回滚。因为上一步的时候已经确保所有的实例中已经把 ZSID = 1 的状态变更为 BLOCK。能正常接收到回滚请求的实例，都会回滚，那些回滚失败或者挂掉的实例是也不会产生写请求，数据也是安全的。

2. 实例接收到变更记录但是 PiMMS 没能正常收到响应  
和 3.3 的 case 一样，正常回滚的实例都可以正常处理，那些回滚失败的也不会产生写入，所以依然是安全的。Keepalive 机制会保障这些回滚失败的实例会恢复到一致的状态。

3. 正常处理了变更记录 2 但是之后实例挂了  
和变更记录 1 一样，也是等在下一个步骤的时候被发现和处理掉。

#### 5. 推送变更记录 3: 把 Zone A 和 Zone B 里的 ZSID = 1 规则置为状态置为 ACTIVE。  
这一步需要确保 Zone A 里面的数据已经全量同步到来 Zone B，因为之前已经阻塞来新的写入，所以这一步通常会在秒级别完成。应用这条变更记录后让新配置生效，变更被应用后，ZSID = 1 规则只允许在 Zone B 写入。并且开放 ZSID = 1 的写入。这一步遇到异常不再是回滚，而是重试，在出现异常和重试的过程中依然是安全的。

1 实例没有接收到变更记录 3  
没有接收到变更记录的推送的实例，状态依然是 RESHARDING，这一状态，只是会停止写入，不会造成其他 Zone 的数据写入。通过 Keepalive 机制实例状态会调整成 ACTIVE。

2 实例已经挂掉  
挂掉的实例已经无法处理业务了，所以也不会对造成不安全的问题。，而且通过 Keepalive 机制，会及时发现这个有问题的实例。

3 实例接收到变更记录但是 PiMMS 没有接收到响应  
此时实例的数据状态已经是正常了，即便是重试或者 Keepalive 都会被幂等掉。只是 PiMMS 不知道这个实例已经正常了而已，Keepalive 会让 PiMMS 获得实例的最新状态。

4 正确处理后，实例挂掉  
这个场景和正常运行的时候挂掉一样，并不会因为刚做了 Zone Sharding 的切换而引起什么问题。通过 Keepalive 机制可以发现挂掉的实例，甚至自动拉起恢复。

#### 为什么会有 RESHARDING 状态
上述的步骤中在推送变更记录 3 的时机是需要等待数据已经被全量同步，如果数据没有同步完成，就会造成 Zone B 的读取数据落后，如果有更新老的数据甚至会造成数据冲突。~~RESHARDING 状态除了阻塞写入等待之外，可以配置成允许写入新数据和更新新写入的数据。而对从 Zone A 生成数据是禁止修改的。这样可以在保障安全的前提下，尽量减少被拒绝的请求。~~ 这个状态并不会影响整个流程，RESHARDING 状态在等待 PiDTS 同步完成后转换为 ACTIVE。如果数据的同步出现来了异常，这一状态可以让切换回滚到起始状态。

## 数据同步的安全保证
在 Zone Sharding 切换的时候提到需要保障数据同步完成之后才可以完成最后异步切换，那么数据同步安全保证需要两个机制来保证：
1. 同步消息不会丢失。
2. 同步顺序不会错乱。

在这两个机制的保障下数据同步的安全就可以得到保障。除此之外，数据同步还需要具备容错能力。在面对特殊场景和业务逻辑 BUG 的时候，不能放大事故，引起更得问题。

### 数据同步顺序安全

### 数据同步幂等

### 数据冲突锁定

### 负责同步数据的 MQ 是否会丢失消息？
### 手动修改了数据？校验失败
### 消息延迟
### 消息乱序
### 消息过期被丢弃

## 剪掉网线